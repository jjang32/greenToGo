# Consul Config provider for Backendless' JS Servers

## Install
````
npm i backendless-consul-config-provider -S
````

## How to use

### Example
````js
const BackendlessConsul = require('backendless-consul-config-provider')

BackendlessConsul
  .provide({
    url     : 'http://localhost:8500',
    rootKey : 'config/service-name/',
    extraKeys: {
      key1: '{version}/path/to/value1',
      foo: {
        bar: '{version}/path/to/value2'
      },
    },
    version : '5.0.1',
  })
  .then(consulConfig => console.log('Consul Config:', consulConfig))
  
````

### Options

#### url:
It's Consul Server URL

#### rootKey:
It's path to Service's Config, will be loaded the whole tree 
For example we provide `config/some-service` as `rootKey` and there is the next structure:

__Consul stricture:__
````
5_0_1
 |- config
     |- some-service
         |- key1 = value1
         |- key2 
             |- key3 = value3
             |- key4
                 |- key5 = value5          
```` 
__As result we will have an object:__
````
{
  key1: value1,
  key2: {
    key3: value3,
    key4: {
      key5: value5
    } 
  }
}
````

#### extraKeys:
It's map of shared Config which can be placed by any keys
For example we have some shared config which used in Service-A and Service-B, the option helps us to get it
You can also use `{version}` in path to shared value, before retrieve it will be replaced by passed `version` value

__Consul stricture:__
```` 
global
 |- some-config
     |- key1 = value1
     |- key2 
         |- key3 = value3
5_0_1
 |- config
     |- key4 = value4
     |- key5 
         |- key6 = value6
         |- key7 = value7  
                     
```` 
__Extra Keys Map__
````
{
  prop1: "global/some-config/key1",
  prop2: {
    prop3: "global/some-config/key2/key3",
    prop4: {
      prop5: "{version}/config/key4",
      prop6: "{version}/config/key5/key6",
      prop7: "{version}/config/key5/key7",
    } 
  }
}
````

__As result we will have an object:__
````
{
  prop1: value1,
  prop2: {
    prop3: value3,
    prop4: {
      prop5: value4,
      prop6: value6,
      prop7: value7,
    } 
  }
}
````

It can be stored in `json` file for most flexible, for ex:

````json
//consul.json
{
  "apiHost": "{version}/config/server/host",
  "apiPort": "{version}/config/server/port",
  "notification": {
    "server": "{version}/config/notification/smtpServer",
    "port": "{version}/config/notification/smtpPort",
    "errorRecipient": "{version}/config/notification/emails"
  },
  "redis": {
    "cache": {
      "host": "{version}/config/redis/cache/host",
      "port": "{version}/config/redis/cache/port",
      "password": "{version}/config/redis/cache/password"
    }
  }
}
````

````js
const BackendlessConsul = require('backendless-consul-config-provider')

BackendlessConsul
  .provide({
    ...
    extraKeys: require('./consul.json')
  })
  
````


#### version:
It's version of Service's Code, the config version must be the same.
The package will load current config version in Consul by key `global/version/product` and if there is wrong version it will wait a few seconds and retry again.
Once both Config and Code versions are equal the package get start retrieving config

The best way to keep the option up-to-date it's pass there version from `package.json`, like this:

````js
const BackendlessConsul = require('backendless-consul-config-provider')

BackendlessConsul
  .provide({
    ...
    version: require('./package.json').version
  })
  
```` 
